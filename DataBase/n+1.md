# N+1

## 通例

User has many articles

名前が`rails`であるarticleの著者を算出したい

## methods

### joins

引数に関連付のシンボルを指定することでレシーバーのモデルと、関連モデルを統合することができる

```rb
User.joins(:articles).where('articles.name = ?', 'rails')
```

使用する場面...`関連テーブルでの絞り込み`

### left_outer_joins

関連テーブルにレコードが存在しない場合にも統合元のレコードは全て取得する

```rb
User.left_outer_joins(:articles).where('articles.name = ?', 'rails')
```

使用する場面...`関連テーブルでの絞り込み`

### eager_load

関連付を一括読み込みするメソッド。

引数に関連付けのシンボルを指定することで、レシーバーのモデルと関連モデルを統合することができる

```rb
User.eager_load(:articles).where('articles.name = ?', 'rails')
```

1. 初回に、SQLの`LEFT OUTER JOIN句`を発行し関連付をキャッシュする
2. ２回目以降はDBではなく、メモリのキャッシュを使って関連データを取得する
3. よってSQLが発行されずN＋1が起こらない

使用する場面...`ループ内で関連テーブルの値を使用する場合`

### preload

関連付を一括読み込みするメソッド

SQLをモデルごとに発行し、`eager_load`同様、関連付をキャッシュする

対象テーブルのデータサイズが大きくJOINのコストが大きい場合に有効

Userテーブル、Articleテーブルそれぞれに１回ずつSQLが発行される

`SELECT句をモデルごとに１回ずつ発行する`

使用する場面...`ループ内で関連テーブルの値を使用する場合`

### includes

SQLの発行時の条件に合わせて`eager_load`, `preload`どちらかの挙動をする

ちなみに、以下の条件に合致する場合には`eager_load`の挙動を、合致しない場合は`preload`の挙動をとる

1. 引数に指定した関連テーブルに対し`joins`メソッドを使用している場合
2. 引数に指定した関連テーブルに対し`where`メソッドを使用している場合
3. 引数に指定した関連テーブルに対して`references`メソッドを使用している場合

<br>

## eager_load, preloadのメリット・デメリット

どちらともメモリにキャッシュを残すため、再利用しないデータはキャッシュしないように注意。

関連テーブルでの絞り込みのみ行う場合は、`joins` or `left_outer_joins`を火なら使うこと

### eager_load

結合するテーブルサイズに注意する必要がある

#### メリット

`preload`とは異なりJOIN句を使うため、関連テーブルでの絞り込みが可能となりSQL発行が１回で済む

#### デメリット

RDBはJOIN句の処理に時間がかかるもの。そのため対象テーブル全体のカラム数や格納されているデータ量など1レコードあたりのデータサイズや単純なレコード数により処理が遅くなる場合がある。

また、RDB側で大きなデータ量を使おうとしてメモリ不足になりディスクを使用することでスロークエリになってしまう可能性もある

<br>

### preload

IN句に指定される要素の数、つまり関連レコード数に注意する必要がある

#### メリット

`preload`は関連モデルごとにSQLを発行するため、`eager_load`で発生するJOIN句特有の問題を回避することができる

#### デメリット

が、SQLを関連モデルごとに発行することで、`eager_laod`よりもSQL発行数が多くなってしまう。

また、RDBによっては１つのSQL内のIN句に指定できる数や、一度に処理できるSQLのバイト数の設定に上限があるため、IN句が長くなることで予期しないRDB側のエラーが発生する可能性がある
